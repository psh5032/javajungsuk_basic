> 교재: 자바의 정석 기초편 - 남궁성 

# 연산자의 결합규칙

- 대입과 단항 연산자만 오른쪽에서 왼쪽으로 연산이 진행된다.
- 나머지 모든 연산자는 **일반적으로 왼쪽에서 오른쪽으로 연산**이 진행된다.

**연산자의 우선순위와 결합법칙은 세가지만 기억하자**
1. 산술 > 비교 > 논리 > 대입. 대입은 제일 마지막에 수행된다 
2. 단항(1) > 이항(2) > 삼항(3). 단항 연산자의 우선순위가 이항 연산자보다 높다.
3. 단항 연산자와 대입 연산자를 제외한 모든 연산의 진행방향은 왼쪽에서 오른쪽이다.

# 증감 연산자
- **증감 연산자가 독립적으로 사용된 경우, 전위형과 후위형의 차이가 없다.**

## 전위형, 후위형
```java
j = ++i; // 전위형

++i: // 증가 후에
j = i; // 참조하여 대입

//--------------------

j = i++;

j = i; // 참조하여 대입 후에
i++; // 증가

```

-  독립적으로 사용된 경우가 아니면 차이가 발생
```java

		int i=5, j=0;

//		j = i++; // 후위형
		j = i;
		i++;
		System.out.println("j=i++; 실행 후, i=" + i +", j="+ j); // i = 6, j = 5

		i=5;        // 결과를 비교하기 위해, i와 j의 값을 다시 5와 0으로 변경
		j=0;

//		j = ++i; // 전위형
		++i;
		j = i; 
		System.out.println("j=++i; 실행 후, i=" + i +", j="+ j); // i = 6, j = 6

```

# 형변환 연산자
|변환|수식|결과|
|---|---|---|
|int -> char|(char)65  |'A'   |
|char -> int|(int)'A'|65|

- 형변환은 유니코드 표에 의해 변경됨
```java
char ch = 'A'

ch 변수안에 'A'가 아니라 유니코드 표의 65를 2진수로 바꾼 숫자가 저장 된다.

```

# 자동 형변환

```java

byte b = 100; // OK. byte타입의 범위 (-128 ~ 127)
byte b = (byte)100; // OK. byte타입으로 자동 형변환하여 대입


int i = 100;
byte b = i; // 에러. int타입을 byte타입에 대입. 위랑 같은데 오류 발생한 이유는 여기서 i는 변수라서 컴파일러가 i에 어떤 숫자가 있는지 확신할 수 없음.
byte b = (byte)i; // OK. byte타입으로 형변환하여 대입


byte b = 1000; // 에러. byte타입의 범위(-128 ~ 127)
byte b = (byte)1000; // OK. 그러나 값손실이 발생해서 변수b에는 -24가 저장됨.

```

# 산술 변환
**연산 전에 피연산자의 타입을 일치시키는 것**
-  두 피연산자의 타입을 같게 일치시킨다. (보다 큰 타입으로 일치)

- 피연산자의 타입이 int보다 작은 타입이면 int로 변환된다. (char는 유니코드 표에 의해서 변환)

```java
byte + short -> int + int -> int
char + short -> int + int -> int

'3' - '0' -> 3이 되는 이유가 바로 '3'이 int로 변환되면 유니코드 51로 바뀌고 '0'의 유니코드는 48이라서 두 수를 빼면 3이 나오기 때문이다.

```

# 문자열의 비교
**문자열 비교에는 == 대신 equals()를 사용해야 한다.**

# 논리연산자 && ||

> 자주 쓰이는 조건식이니까 잘 봐두자!

## 1. 문자 ch는 숫자('0'~'9')인지 확인하는 식은 다음과 같이 쓸 수 있다.

```java
'0' <= ch && ch <= '9'
// 48 <= 53 && 53 <= 57
```

## 2. 문자 ch는 대문자 또는 소문자이다.

```java
('a' <= ch && ch <= 'z') || ('A'<= ch && ch <= 'Z')
```

# 논리 부정 연산자 !
```java
boolean b = true;

!!b -> !!true -> !false -> true
// 논리 부정 연산자는 단항 연산자이다. 즉, 오른쪽에서 왼쪽으로 연산이 진행된다.
// 대입 연산자도 오른쪽에서 왼쪽으로 진행

```

# 조건 연산자 ? :

- 조건식의 결과에 따라 연산 결과를 달리한다.
- 조건식의 결과가 참이면 x값을 선택하고, 거짓이면 y값을 선택한다.
```java

result = (x > y) ? x : y ; // 괄호 생략 가능
result = (5 > 3) ? 5 : 3 ;
result = (true) ? 5 : 3 ;
result = 5 ; // 조건식이 true여서 x값인 5를 선택
```

# 복합 대입 연산자

|||
|---|---|
|i += 3;|i = i + 3;|  
|i *= 10 + j;|i = i * (10 + j);| 

- 두번째 식은 조심해야함. 10 + j는 괄호를 쳐야 한다. 안 그러면 먼저 계산 될 수 도 있음 
